{"ast":null,"code":"import _objectWithoutProperties from \"/Users/jonathangross/GA-26/dadsgonebad/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport UUID from 'uuid-js';\nimport { guardPermission, getExponentPushTokenAsync, getDevicePushTokenAsync } from './ExponentNotificationsHelper.web'; // Register `message`'s event listener (side-effect)\n\nimport './ExponentNotifications.fx.web';\n\nfunction transformLocalNotification(notification, tag) {\n  const _notification$web = notification.web,\n        web = _notification$web === void 0 ? {} : _notification$web,\n        abstractNotification = _objectWithoutProperties(notification, [\"web\"]);\n\n  tag = web.tag || tag;\n  const nativeNotification = { ...abstractNotification,\n    tag,\n    ...web,\n    // Show that this notification is a local notification\n    _isLocal: true\n  };\n  return [nativeNotification.title, nativeNotification];\n}\n\nfunction generateID() {\n  return UUID.create().toString();\n}\n\nasync function getRegistrationAsync() {\n  guardPermission();\n  const registration = await navigator.serviceWorker.getRegistration();\n\n  if (!registration) {\n    throw new Error('Failed to get notification registration!');\n  }\n\n  return registration;\n}\n\nasync function getNotificationsAsync(tag) {\n  const registration = await getRegistrationAsync();\n  const notifications = await registration.getNotifications(tag ? {\n    tag\n  } : undefined);\n  return notifications;\n}\n\nexport default {\n  async presentLocalNotification(notification) {\n    const registration = await getRegistrationAsync();\n    const tag = generateID();\n    registration.showNotification(...transformLocalNotification(notification, tag));\n    return tag;\n  },\n\n  async scheduleLocalNotification(notification, options = {}) {\n    if (options.intervalMs) {\n      const registration = await getRegistrationAsync();\n      const tag = generateID();\n      setTimeout(() => {\n        registration.showNotification(...transformLocalNotification(notification, tag));\n      }, options.intervalMs);\n      return tag;\n    } else if (options.time) {\n      const intervalMs = options.time - Date.now();\n\n      if (intervalMs < 0) {\n        throw new Error('Expo.Notifications.scheduleLocalNotification(): options.time must be some time in the future.');\n      }\n\n      return this.scheduleLocalNotification(notification, {\n        intervalMs\n      });\n    }\n\n    throw new Error(\"Expo.Notifications.scheduleLocalNotification() options \".concat(JSON.stringify(options, null, 2), \" are not supported yet.\"));\n  },\n\n  async dismissNotification(notificationId) {\n    const notifications = await getNotificationsAsync(notificationId);\n\n    for (const notification of notifications) {\n      notification.close();\n    }\n  },\n\n  async dismissAllNotifications() {\n    this.dismissNotification();\n  },\n\n  async cancelScheduledNotificationAsync(notificationId) {\n    this.dismissNotification(notificationId);\n  },\n\n  async cancelAllScheduledNotificationsAsync() {\n    this.dismissNotification();\n  },\n\n  async getExponentPushTokenAsync() {\n    return await getExponentPushTokenAsync();\n  },\n\n  async getDevicePushTokenAsync() {\n    return await getDevicePushTokenAsync();\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}