{"ast":null,"code":"import { Platform } from '@unimodules/core';\nimport path from 'path-browserify';\nimport { PixelRatio } from 'react-native';\nimport URL from 'url-parse';\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { manifestBaseUrl, getManifest } from './PlatformUtils'; // Fast lookup check if asset map has any overrides in the manifest\n\nconst assetMapOverride = getManifest().assetMapOverride;\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\n\nexport function selectAssetSource(meta) {\n  // Override with the asset map in manifest if available\n  if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n    meta = { ...meta,\n      ...assetMapOverride[meta.hash]\n    };\n  } // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n\n\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex(s => s === scale);\n  const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash; // Allow asset processors to directly provide the URL to load\n\n  const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n\n  if (uri) {\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  } // Check if the assetUrl was overridden in the manifest\n\n\n  const assetUrlOverride = getManifest().assetUrlOverride;\n\n  if (assetUrlOverride) {\n    const uri = path.join(assetUrlOverride, hash);\n    return {\n      uri: resolveUri(uri),\n      hash\n    };\n  }\n\n  const fileScale = scale === 1 ? '' : \"@\".concat(scale, \"x\");\n  const fileExtension = meta.type ? \".\".concat(encodeURIComponent(meta.type)) : '';\n  const suffix = \"/\".concat(encodeURIComponent(meta.name)).concat(fileScale).concat(fileExtension, \"?platform=\").concat(encodeURIComponent(Platform.OS), \"&hash=\").concat(encodeURIComponent(meta.hash)); // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix;\n    return {\n      uri,\n      hash\n    };\n  } // For assets during development, we use the development server's URL origin\n\n\n  if (getManifest().developer) {\n    const baseUrl = new URL(getManifest().bundleUrl);\n    baseUrl.set('pathname', meta.httpServerLocation + suffix);\n    return {\n      uri: baseUrl.href,\n      hash\n    };\n  } // Production CDN URIs are based on each asset file hash\n\n\n  return {\n    uri: \"https://d1wp6m56sqw74a.cloudfront.net/~assets/\".concat(encodeURIComponent(hash)),\n    hash\n  };\n}\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\n\nexport function resolveUri(uri) {\n  if (!manifestBaseUrl) {\n    return uri;\n  }\n\n  const _ref = new URL(uri),\n        protocol = _ref.protocol;\n\n  if (protocol !== '') {\n    return uri;\n  }\n\n  const baseUrl = new URL(manifestBaseUrl);\n  const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n  baseUrl.set('pathname', resolvedPath);\n  return baseUrl.href;\n}","map":null,"metadata":{},"sourceType":"module"}