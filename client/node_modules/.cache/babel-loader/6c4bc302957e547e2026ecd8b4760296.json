{"ast":null,"code":"import { Platform } from '@unimodules/core';\nimport { getAssetByID } from './AssetRegistry';\nimport * as AssetSources from './AssetSources';\nimport * as AssetUris from './AssetUris';\nimport { getEmbeddedAssetUri } from './EmbeddedAssets';\nimport * as ImageAssets from './ImageAssets';\nimport { downloadAsync, IS_MANAGED_ENV } from './PlatformUtils';\nimport resolveAssetSource from './resolveAssetSource';\nexport class Asset {\n  constructor({\n    name,\n    type,\n    hash = null,\n    uri,\n    width,\n    height\n  }) {\n    this.hash = null;\n    this.localUri = null;\n    this.width = null;\n    this.height = null;\n    this.downloading = false;\n    this.downloaded = false;\n    this._downloadCallbacks = [];\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n\n    if (typeof height === 'number') {\n      this.height = height;\n    } // This only applies to assets that are bundled in Expo standalone apps\n\n\n    if (IS_MANAGED_ENV && hash) {\n      this.localUri = getEmbeddedAssetUri(hash, type);\n\n      if (this.localUri) {\n        this.downloaded = true;\n      }\n    }\n\n    if (Platform.OS === 'web') {\n      if (!name) {\n        this.name = AssetUris.getFilename(uri);\n      }\n\n      if (!type) {\n        this.type = AssetUris.getFileExtension(uri);\n      }\n    }\n  }\n\n  static loadAsync(moduleId) {\n    const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n    return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule) {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    }\n\n    const meta = getAssetByID(virtualAssetModule);\n\n    if (!meta) {\n      throw new Error(\"Module \\\"\".concat(virtualAssetModule, \"\\\" is missing from the asset registry\"));\n    } // Outside of the managed env we need the moduleId to initialize the asset\n    // because resolveAssetSource depends on it\n\n\n    if (!IS_MANAGED_ENV) {\n      const _resolveAssetSource = resolveAssetSource(virtualAssetModule),\n            uri = _resolveAssetSource.uri;\n\n      const asset = new Asset({\n        name: meta.name,\n        type: meta.type,\n        hash: meta.hash,\n        uri,\n        width: meta.width,\n        height: meta.height\n      }); // TODO: FileSystem should probably support 'downloading' from drawable\n      // resources But for now it doesn't (it only supports raw resources) and\n      // React Native's Image works fine with drawable resource names for\n      // images.\n\n      if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n        asset.localUri = asset.uri;\n        asset.downloaded = true;\n      }\n\n      Asset.byHash[meta.hash] = asset;\n      return asset;\n    }\n\n    return Asset.fromMetadata(meta);\n  }\n\n  static fromMetadata(meta) {\n    // The hash of the whole asset, not to be confused with the hash of a specific file returned\n    // from `selectAssetSource`\n    const metaHash = meta.hash;\n\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    } else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n      throw new Error('Assets must be initialized with Asset.fromModule');\n    }\n\n    const _AssetSources$selectA = AssetSources.selectAssetSource(meta),\n          uri = _AssetSources$selectA.uri,\n          hash = _AssetSources$selectA.hash;\n\n    const asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri) {\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    } // Possibly a Base64-encoded URI\n\n\n    let type = '';\n\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      const extension = AssetUris.getFileExtension(uri);\n      type = extension.startsWith('.') ? extension.substring(1) : extension;\n    }\n\n    const asset = new Asset({\n      name: '',\n      type,\n      hash: null,\n      uri\n    });\n    Asset.byUri[uri] = asset;\n    return asset;\n  }\n\n  async downloadAsync() {\n    if (this.downloaded) {\n      return;\n    }\n\n    if (this.downloading) {\n      await new Promise((resolve, reject) => {\n        this._downloadCallbacks.push({\n          resolve,\n          reject\n        });\n      });\n      return;\n    }\n\n    this.downloading = true;\n\n    try {\n      if (Platform.OS === 'web') {\n        if (ImageAssets.isImageType(this.type)) {\n          const _ref = await ImageAssets.getImageInfoAsync(this.uri),\n                width = _ref.width,\n                height = _ref.height,\n                name = _ref.name;\n\n          this.width = width;\n          this.height = height;\n          this.name = name;\n        } else {\n          this.name = AssetUris.getFilename(this.uri);\n        }\n      }\n\n      this.localUri = await downloadAsync(this.uri, this.hash, this.type, this.name);\n      this.downloaded = true;\n\n      this._downloadCallbacks.forEach(({\n        resolve\n      }) => resolve());\n    } catch (e) {\n      this._downloadCallbacks.forEach(({\n        reject\n      }) => reject(e));\n\n      throw e;\n    } finally {\n      this.downloading = false;\n      this._downloadCallbacks = [];\n    }\n  }\n\n}\nAsset.byHash = {};\nAsset.byUri = {};","map":null,"metadata":{},"sourceType":"module"}