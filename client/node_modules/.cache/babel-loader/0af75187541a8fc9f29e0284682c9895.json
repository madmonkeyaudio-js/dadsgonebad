{"ast":null,"code":"import Constants from 'expo-constants';\nimport { Dimensions, NativeEventEmitter, NativeModules, Platform, findNodeHandle } from 'react-native';\nconst ExponentAR = NativeModules.ExponentAR || {};\nconst emitter = new NativeEventEmitter(ExponentAR);\n/**\n * Tracking Configuration\n * Options for how ARKit constructs a scene coordinate system based on real-world device motion.\n * https://developer.apple.com/documentation/arkit/arconfiguration\n */\n\nexport var TrackingConfiguration;\n\n(function (TrackingConfiguration) {\n  /**\n   * Provides high-quality AR experiences that use the rear-facing camera precisely track a device's\n   * position and orientation and allow plane detection and hit testing.\n   */\n  TrackingConfiguration[\"World\"] = \"ARWorldTrackingConfiguration\";\n  /**\n   * Provides basic AR experiences that use the rear-facing camera and track only a device's\n   * orientation.\n   */\n\n  TrackingConfiguration[\"Orientation\"] = \"AROrientationTrackingConfiguration\";\n  /**\n   * Provides AR experiences that use the front-facing camera and track the movement and expressions\n   * of the user's face.\n   */\n\n  TrackingConfiguration[\"Face\"] = \"ARFaceTrackingConfiguration\";\n})(TrackingConfiguration || (TrackingConfiguration = {}));\n\nexport var DepthDataQuality;\n\n(function (DepthDataQuality) {\n  DepthDataQuality[\"Low\"] = \"AVDepthDataQualityLow\";\n  DepthDataQuality[\"High\"] = \"AVDepthDataQualityHigh\";\n})(DepthDataQuality || (DepthDataQuality = {}));\n\nexport var DepthDataAccuracy;\n\n(function (DepthDataAccuracy) {\n  DepthDataAccuracy[\"Absolute\"] = \"AVDepthDataAccuracyAbsolute\";\n  DepthDataAccuracy[\"Relative\"] = \"AVDepthDataAccuracyRelative\";\n})(DepthDataAccuracy || (DepthDataAccuracy = {}));\n\nexport var BlendShape;\n\n(function (BlendShape) {\n  BlendShape[\"BrowDownL\"] = \"browDown_L\";\n  BlendShape[\"BrowDownR\"] = \"browDown_R\";\n  BlendShape[\"BrowInnerUp\"] = \"browInnerUp\";\n  BlendShape[\"BrowOuterUpL\"] = \"browOuterUp_L\";\n  BlendShape[\"BrowOuterUpR\"] = \"browOuterUp_R\";\n  BlendShape[\"CheekPuff\"] = \"cheekPuff\";\n  BlendShape[\"CheekSquintL\"] = \"cheekSquint_L\";\n  BlendShape[\"CheekSquintR\"] = \"cheekSquint_R\";\n  BlendShape[\"EyeBlinkL\"] = \"eyeBlink_L\";\n  BlendShape[\"EyeBlinkR\"] = \"eyeBlink_R\";\n  BlendShape[\"EyeLookDownL\"] = \"eyeLookDown_L\";\n  BlendShape[\"EyeLookDownR\"] = \"eyeLookDown_R\";\n  BlendShape[\"EyeLookInL\"] = \"eyeLookIn_L\";\n  BlendShape[\"EyeLookInR\"] = \"eyeLookIn_R\";\n  BlendShape[\"EyeLookOutL\"] = \"eyeLookOut_L\";\n  BlendShape[\"EyeLookOutR\"] = \"eyeLookOut_R\";\n  BlendShape[\"EyeLookUpL\"] = \"eyeLookUp_L\";\n  BlendShape[\"EyeLookUpR\"] = \"eyeLookUp_R\";\n  BlendShape[\"EyeSquintL\"] = \"eyeSquint_L\";\n  BlendShape[\"EyeSquintR\"] = \"eyeSquint_R\";\n  BlendShape[\"EyeWideL\"] = \"eyeWide_L\";\n  BlendShape[\"EyeWideR\"] = \"eyeWide_R\";\n  BlendShape[\"JawForward\"] = \"jawForward\";\n  BlendShape[\"JawLeft\"] = \"jawLeft\";\n  BlendShape[\"JawOpen\"] = \"jawOpen\";\n  BlendShape[\"JawRight\"] = \"jawRight\";\n  BlendShape[\"MouthClose\"] = \"mouthClose\";\n  BlendShape[\"MouthDimpleL\"] = \"mouthDimple_L\";\n  BlendShape[\"MouthDimpleR\"] = \"mouthDimple_R\";\n  BlendShape[\"MouthFrownL\"] = \"mouthFrown_L\";\n  BlendShape[\"MouthFrownR\"] = \"mouthFrown_R\";\n  BlendShape[\"MouthFunnel\"] = \"mouthFunnel\";\n  BlendShape[\"MouthLeft\"] = \"mouthLeft\";\n  BlendShape[\"MouthLowerDownL\"] = \"mouthLowerDown_L\";\n  BlendShape[\"MouthLowerDownR\"] = \"mouthLowerDown_R\";\n  BlendShape[\"MouthPressL\"] = \"mouthPress_L\";\n  BlendShape[\"MouthPressR\"] = \"mouthPress_R\";\n  BlendShape[\"MouthPucker\"] = \"mouthPucker\";\n  BlendShape[\"MouthRight\"] = \"mouthRight\";\n  BlendShape[\"MouthRollLower\"] = \"mouthRollLower\";\n  BlendShape[\"MouthRollUpper\"] = \"mouthRollUpper\";\n  BlendShape[\"MouthShrugLower\"] = \"mouthShrugLower\";\n  BlendShape[\"MouthShrugUpper\"] = \"mouthShrugUpper\";\n  BlendShape[\"MouthSmileL\"] = \"mouthSmile_L\";\n  BlendShape[\"MouthSmileR\"] = \"mouthSmile_R\";\n  BlendShape[\"MouthStretchL\"] = \"mouthStretch_L\";\n  BlendShape[\"MouthStretchR\"] = \"mouthStretch_R\";\n  BlendShape[\"MouthUpperUpL\"] = \"mouthUpperUp_L\";\n  BlendShape[\"MouthUpperUpR\"] = \"mouthUpperUp_R\";\n  BlendShape[\"NoseSneerL\"] = \"noseSneer_L\";\n  BlendShape[\"NoseSneerR\"] = \"noseSneer_R\";\n})(BlendShape || (BlendShape = {}));\n\nexport var FaceAnchorProp;\n\n(function (FaceAnchorProp) {\n  FaceAnchorProp[\"Geometry\"] = \"geometry\";\n  FaceAnchorProp[\"BlendShapes\"] = \"blendShapes\";\n})(FaceAnchorProp || (FaceAnchorProp = {}));\n/**\n * Plane Detection\n * Options for whether and how ARKit detects flat surfaces in captured images.\n * https://developer.apple.com/documentation/arkit/arplanedetection\n */\n\n\nexport var PlaneDetection;\n\n(function (PlaneDetection) {\n  /**\n   * No plane detection is run\n   */\n  PlaneDetection[\"None\"] = \"none\";\n  /**\n   * Plane detection determines horizontal planes in the scene\n   */\n\n  PlaneDetection[\"Horizontal\"] = \"horizontal\";\n  /**\n   * Plane detection determines vertical planes in the scene\n   */\n\n  PlaneDetection[\"Vertical\"] = \"vertical\";\n})(PlaneDetection || (PlaneDetection = {}));\n/**\n * Hit-Test Result Types\n * Possible types for specifying a hit-test search, or for the result of a hit-test search.\n * https://developer.apple.com/documentation/arkit/arhittestresulttype\n */\n\n\nexport var HitTestResultTypes;\n\n(function (HitTestResultTypes) {\n  /**\n   * Result type from intersecting the nearest feature point.\n   */\n  HitTestResultTypes[\"FeaturePoint\"] = \"featurePoint\";\n  /**\n   * Result type from intersecting a horizontal plane estimate, determined for the current frame.\n   */\n\n  HitTestResultTypes[\"HorizontalPlane\"] = \"horizontalPlane\";\n  /**\n   * Result type from intersecting a vertical plane estimate, determined for the current frame.\n   */\n\n  HitTestResultTypes[\"VerticalPlane\"] = \"verticalPlane\";\n  /**\n   * Result type from intersecting with an existing plane anchor.\n   */\n\n  HitTestResultTypes[\"ExistingPlane\"] = \"existingPlane\";\n  /**\n   * Result type from intersecting with an existing plane anchor, taking into account the plane’s\n   * extent.\n   */\n\n  HitTestResultTypes[\"ExistingPlaneUsingExtent\"] = \"existingPlaneUsingExtent\";\n  /**\n   * Result type from intersecting with an existing plane anchor, taking into account the plane’s\n   * geometry.\n   */\n\n  HitTestResultTypes[\"ExistingPlaneUsingGeometry\"] = \"existingPlaneUsingGeometry\";\n})(HitTestResultTypes || (HitTestResultTypes = {}));\n/**\n * World Alignment\n * Options for how ARKit constructs a scene coordinate system based on real-world device motion.\n * https://developer.apple.com/documentation/arkit/arworldalignment\n */\n\n\nexport var WorldAlignment;\n\n(function (WorldAlignment) {\n  /**\n   * Aligns the world with gravity that is defined by vector (0, -1, 0).\n   */\n  WorldAlignment[\"Gravity\"] = \"gravity\";\n  /**\n   * Aligns the world with gravity that is defined by the vector (0, -1, 0) and heading (w.r.t. true\n   * north) that is given by the vector (0, 0, -1).\n   */\n\n  WorldAlignment[\"GravityAndHeading\"] = \"gravityAndHeading\";\n  /**\n   * Aligns the world with the camera’s orientation.\n   */\n\n  WorldAlignment[\"AlignmentCamera\"] = \"alignmentCamera\";\n})(WorldAlignment || (WorldAlignment = {}));\n\nexport var EventType;\n\n(function (EventType) {\n  EventType[EventType[\"FrameDidUpdate\"] = ExponentAR.frameDidUpdate] = \"FrameDidUpdate\";\n  EventType[EventType[\"DidFailWithError\"] = ExponentAR.didFailWithError] = \"DidFailWithError\";\n  EventType[EventType[\"AnchorsDidUpdate\"] = ExponentAR.anchorsDidUpdate] = \"AnchorsDidUpdate\";\n  EventType[EventType[\"CameraDidChangeTrackingState\"] = ExponentAR.cameraDidChangeTrackingState] = \"CameraDidChangeTrackingState\";\n  EventType[EventType[\"SessionWasInterrupted\"] = ExponentAR.sessionWasInterrupted] = \"SessionWasInterrupted\";\n  EventType[EventType[\"SessionInterruptionEnded\"] = ExponentAR.sessionInterruptionEnded] = \"SessionInterruptionEnded\";\n})(EventType || (EventType = {}));\n\nexport var AnchorType;\n\n(function (AnchorType) {\n  AnchorType[\"Face\"] = \"ARFaceAnchor\";\n  AnchorType[\"Image\"] = \"ARImageAnchor\";\n  AnchorType[\"Plane\"] = \"ARPlaneAnchor\";\n  AnchorType[\"Anchor\"] = \"ARAnchor\";\n})(AnchorType || (AnchorType = {}));\n\nexport var AnchorEventType;\n\n(function (AnchorEventType) {\n  AnchorEventType[\"Add\"] = \"add\";\n  AnchorEventType[\"Update\"] = \"update\";\n  AnchorEventType[\"Remove\"] = \"remove\";\n})(AnchorEventType || (AnchorEventType = {}));\n\nexport var FrameAttribute;\n\n(function (FrameAttribute) {\n  FrameAttribute[\"Anchors\"] = \"anchors\";\n  FrameAttribute[\"RawFeaturePoints\"] = \"rawFeaturePoints\";\n  FrameAttribute[\"LightEstimation\"] = \"lightEstimation\";\n  FrameAttribute[\"CapturedDepthData\"] = \"capturedDepthData\";\n})(FrameAttribute || (FrameAttribute = {}));\n\nexport var TrackingState;\n\n(function (TrackingState) {\n  /** Tracking is not available. */\n  TrackingState[\"NotAvailable\"] = \"ARTrackingStateNotAvailable\";\n  /** Tracking is limited. See tracking reason for details. */\n\n  TrackingState[\"Limited\"] = \"ARTrackingStateLimited\";\n  /** Tracking is Normal. */\n\n  TrackingState[\"Normal\"] = \"ARTrackingStateNormal\";\n})(TrackingState || (TrackingState = {}));\n\nexport var TrackingStateReason;\n\n(function (TrackingStateReason) {\n  /** Tracking is not limited. */\n  TrackingStateReason[\"None\"] = \"ARTrackingStateReasonNone\";\n  /** Tracking is limited due to initialization in progress. */\n\n  TrackingStateReason[\"Initializing\"] = \"ARTrackingStateReasonInitializing\";\n  /** Tracking is limited due to a excessive motion of the camera. */\n\n  TrackingStateReason[\"ExcessiveMotion\"] = \"ARTrackingStateReasonExcessiveMotion\";\n  /** Tracking is limited due to a lack of features visible to the camera. */\n\n  TrackingStateReason[\"InsufficientFeatures\"] = \"ARTrackingStateReasonInsufficientFeatures\";\n  /** Tracking is limited due to a relocalization in progress. */\n\n  TrackingStateReason[\"Relocalizing\"] = \"ARTrackingStateReasonRelocalizing\";\n})(TrackingStateReason || (TrackingStateReason = {}));\n\nexport function getVersion() {\n  return ExponentAR.ARKitVersion;\n}\nconst AvailabilityErrorMessages = {\n  Simulator: \"Cannot run EXGL in a simulator\",\n  ANineChip: \"ARKit can only run on iOS devices with A9 (2015) or greater chips! This is a\",\n  ARKitOnlyOnIOS: \"ARKit can only run on an iOS device! This is a\"\n};\nexport function isAvailable() {\n  // Device has A9 chip\n  const hasA9Chip = Constants.deviceYearClass && Constants.deviceYearClass > 2014;\n\n  if (!Constants.isDevice || // Prevent Simulators\n  // @ts-ignore\n  Platform.isTVOS || Platform.OS !== 'ios' || // Device is iOS\n  !hasA9Chip || !ExponentAR.isSupported || // ARKit is included in the build\n  !ExponentAR.startAsync // Older SDK versions (27 and lower) that are fully compatible\n  ) {\n      return false;\n    }\n\n  return true;\n}\nexport function getUnavailabilityReason() {\n  if (!Constants.isDevice) {\n    return AvailabilityErrorMessages.Simulator;\n  } else if (Platform.OS !== 'ios') {\n    return \"\".concat(AvailabilityErrorMessages.ARKitOnlyOnIOS, \" \").concat(Platform.OS, \" device\");\n  } else if (Constants.deviceYearClass == null || Constants.deviceYearClass < 2015) {\n    return \"\".concat(AvailabilityErrorMessages.ANineChip, \" \").concat(Constants.deviceYearClass, \" device\");\n  }\n\n  return 'Unknown Reason';\n}\nexport function onFrameDidUpdate(listener) {\n  return _addListener(EventType.FrameDidUpdate, listener);\n}\nexport function onDidFailWithError(listener) {\n  return _addListener(EventType.DidFailWithError, listener);\n}\nexport function onAnchorsDidUpdate(listener) {\n  return _addListener(EventType.AnchorsDidUpdate, listener);\n}\nexport function onCameraDidChangeTrackingState(listener) {\n  return _addListener(EventType.CameraDidChangeTrackingState, listener);\n}\nexport function onSessionWasInterrupted(listener) {\n  return _addListener(EventType.SessionWasInterrupted, listener);\n}\nexport function onSessionInterruptionEnded(listener) {\n  return _addListener(EventType.SessionInterruptionEnded, listener);\n}\n\nfunction _addListener(eventType, event) {\n  return emitter.addListener(eventType, event);\n}\n\nexport function removeAllListeners(eventType) {\n  emitter.removeAllListeners(eventType);\n} // TODO: support multiple types (take an array or bit flags)\n\nexport function performHitTest(point, types) {\n  if (ExponentAR.performHitTest) {\n    return ExponentAR.performHitTest(point, types);\n  }\n\n  throw new Error(\"AR hit testing is not supported on this device\");\n}\nexport async function setDetectionImagesAsync(images) {\n  if (ExponentAR.setDetectionImagesAsync) {\n    await ExponentAR.setDetectionImagesAsync(images);\n  }\n}\nexport function getCurrentFrame(attributes) {\n  if (ExponentAR.getCurrentFrame) {\n    return ExponentAR.getCurrentFrame(attributes);\n  }\n\n  throw new Error(\"AR is not supported on this device\");\n}\nexport function getARMatrices(near, far) {\n  if (ExponentAR.getARMatrices) {\n    return ExponentAR.getARMatrices(near, far);\n  }\n\n  throw new Error(\"AR is not supported on this device\");\n}\nexport async function stopAsync() {\n  if (ExponentAR.stopAsync) {\n    await ExponentAR.stopAsync();\n  }\n}\nexport async function startAsync(node, configuration) {\n  let handle = typeof node === 'number' ? node : _getNodeHandle(node);\n\n  if (ExponentAR.startAsync) {\n    return await ExponentAR.startAsync(handle, configuration);\n  }\n\n  throw new Error(\"AR is not supported on this device\");\n}\n\nfunction _getNodeHandle(component) {\n  let handle = findNodeHandle(component);\n\n  if (handle === null) {\n    throw new Error(\"Could not find the React node handle for the AR component: \".concat(component));\n  }\n\n  return handle;\n}\n\nexport function reset() {\n  if (ExponentAR.reset) {\n    ExponentAR.reset();\n  }\n}\nexport function resume() {\n  if (ExponentAR.resume) {\n    ExponentAR.resume();\n  }\n}\nexport function pause() {\n  if (ExponentAR.pause) {\n    ExponentAR.pause();\n  }\n}\nexport async function setConfigurationAsync(configuration) {\n  if (ExponentAR.setConfigurationAsync) {\n    await ExponentAR.setConfigurationAsync(configuration);\n  }\n}\nexport function getProvidesAudioData() {\n  if (ExponentAR.getProvidesAudioData) {\n    return ExponentAR.getProvidesAudioData();\n  }\n\n  return false;\n}\nexport function setProvidesAudioData(providesAudioData) {\n  if (ExponentAR.setProvidesAudioData) {\n    ExponentAR.setProvidesAudioData(providesAudioData);\n  }\n}\nexport function setPlaneDetection(planeDetection) {\n  if (ExponentAR.setPlaneDetection) {\n    ExponentAR.setPlaneDetection(planeDetection);\n  }\n}\nexport function getPlaneDetection() {\n  if (ExponentAR.getPlaneDetection) {\n    return ExponentAR.getPlaneDetection();\n  }\n\n  throw new Error(\"AR plane detection is not supported on this device\");\n}\nexport function getCameraTexture() {\n  if (ExponentAR.getCameraTexture) {\n    return ExponentAR.getCameraTexture();\n  }\n\n  throw new Error(\"AR camera textures are not supported on this device\");\n}\nexport async function setWorldOriginAsync(matrix_float4x4) {\n  if (ExponentAR.setWorldOriginAsync) {\n    await ExponentAR.setWorldOriginAsync(matrix_float4x4);\n  }\n}\nexport function setLightEstimationEnabled(isLightEstimationEnabled) {\n  if (ExponentAR.setLightEstimationEnabled) {\n    ExponentAR.setLightEstimationEnabled(isLightEstimationEnabled);\n  }\n}\nexport function getLightEstimationEnabled() {\n  if (ExponentAR.getLightEstimationEnabled) {\n    return ExponentAR.getLightEstimationEnabled();\n  }\n\n  return false;\n}\nexport function setAutoFocusEnabled(isAutoFocusEnabled) {\n  if (ExponentAR.setAutoFocusEnabled) {\n    ExponentAR.setAutoFocusEnabled(isAutoFocusEnabled);\n  }\n}\nexport function getAutoFocusEnabled() {\n  if (ExponentAR.getAutoFocusEnabled) {\n    return ExponentAR.getAutoFocusEnabled();\n  }\n\n  return false;\n}\nexport function setWorldAlignment(worldAlignment) {\n  if (ExponentAR.setWorldAlignment) {\n    ExponentAR.setWorldAlignment(worldAlignment);\n  }\n}\nexport function getWorldAlignment() {\n  if (ExponentAR.getWorldAlignment) {\n    return ExponentAR.getWorldAlignment();\n  }\n\n  throw new Error(\"AR world alignment is not supported on this device\");\n}\nexport function isConfigurationAvailable(configuration) {\n  const _Dimensions$get = Dimensions.get('window'),\n        width = _Dimensions$get.width,\n        height = _Dimensions$get.height; // @ts-ignore: re-evaluate this for the new iPhones (2018)\n\n\n  const isX = (width === 812 || height === 812) && !Platform.isTVOS && !Platform.isPad;\n\n  if (configuration === TrackingConfiguration.Face && isX && isAvailable()) {\n    return true;\n  }\n\n  return !!ExponentAR[configuration];\n}\nexport function getSupportedVideoFormats(configuration) {\n  const videoFormats = {\n    [TrackingConfiguration.World]: 'WorldTrackingVideoFormats',\n    [TrackingConfiguration.Orientation]: 'OrientationTrackingVideoFormats',\n    [TrackingConfiguration.Face]: 'FaceTrackingVideoFormats'\n  };\n  const videoFormat = videoFormats[configuration];\n  return ExponentAR[videoFormat] || [];\n}\nexport function isFrontCameraAvailable() {\n  return isConfigurationAvailable(TrackingConfiguration.Face);\n}\nexport function isRearCameraAvailable() {\n  return isConfigurationAvailable(TrackingConfiguration.World);\n}\n/* Legacy constants */\n\n/**\n * A deprecated alias for `PlaneDetection`\n * July 8, 2019\n */\n\nexport const PlaneDetectionTypes = PlaneDetection;\n/**\n * A deprecated alias for `WorldAlignment`\n * July 8, 2019\n */\n\nexport const WorldAlignmentTypes = WorldAlignment;\n/**\n * A deprecated alias for `EventType`\n * July 8, 2019\n */\n\nexport const EventTypes = EventType;\n/**\n * A deprecated alias for `AnchorType`\n * July 8, 2019\n */\n\nexport const AnchorTypes = AnchorType;\n/**\n * A deprecated alias for `AnchorEventType`\n * July 8, 2019\n */\n\nexport const AnchorEventTypes = AnchorEventType;\n/**\n * A deprecated alias for `FrameAttribute`\n * July 8, 2019\n */\n\nexport const FrameAttributes = FrameAttribute;\n/**\n * A deprecated alias for `TrackingState`\n * July 8, 2019\n */\n\nexport const TrackingStates = TrackingState;\n/**\n * A deprecated alias for `TrackingStateReason`\n * July 8, 2019\n */\n\nexport const TrackingStateReasons = TrackingStateReason;\n/**\n * A deprecated alias for `TrackingConfiguration`\n * July 8, 2019\n */\n\nexport const TrackingConfigurations = TrackingConfiguration;","map":null,"metadata":{},"sourceType":"module"}