{"ast":null,"code":"import Constants from 'expo-constants';\nimport qs from 'qs';\nimport { openAuthSessionAsync, dismissAuthSession } from 'expo-web-browser';\nimport Linking from './Linking/Linking';\nconst BASE_URL = \"https://auth.expo.io\";\nlet _authLock = false;\n\nasync function startAsync(options) {\n  const returnUrl = options.returnUrl || getDefaultReturnUrl();\n  const authUrl = options.authUrl;\n  const startUrl = getStartUrl(authUrl, returnUrl); // Prevent accidentally starting to an empty url\n\n  if (!authUrl) {\n    throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n  } // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n\n\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n    }\n\n    return {\n      type: 'locked'\n    };\n  } // About to start session, set lock\n\n\n  _authLock = true;\n  let result;\n\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  } // Handle failures\n\n\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n\n  if (!result.url) {\n    if (result.type) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  let _parseUrl = parseUrl(result.url),\n      params = _parseUrl.params,\n      errorCode = _parseUrl.errorCode;\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    url: result.url\n  };\n}\n\nfunction dismiss() {\n  dismissAuthSession();\n}\n\nasync function _openWebBrowserAsync(startUrl, returnUrl) {\n  // $FlowIssue: Flow thinks the awaited result can be a promise\n  let result = await openAuthSessionAsync(startUrl, returnUrl);\n\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return {\n      type: result.type\n    };\n  }\n\n  return result;\n}\n\nfunction getStartUrl(authUrl, returnUrl) {\n  let queryString = qs.stringify({\n    authUrl,\n    returnUrl\n  });\n  return \"\".concat(getRedirectUrl(), \"/start?\").concat(queryString);\n}\n\nfunction getRedirectUrl() {\n  const redirectUrl = \"\".concat(BASE_URL, \"/\").concat(Constants.manifest.id);\n\n  if (__DEV__) {\n    _warnIfAnonymous(Constants.manifest.id, redirectUrl);\n  }\n\n  return redirectUrl;\n}\n\nfunction getDefaultReturnUrl() {\n  return Linking.makeUrl('expo-auth-session');\n}\n\nfunction parseUrl(url) {\n  let parts = url.split('#');\n  let hash = parts[1];\n  let partsWithoutHash = parts[0].split('?');\n  let queryString = partsWithoutHash[partsWithoutHash.length - 1]; // Get query string (?hello=world)\n\n  let parsedSearch = qs.parse(queryString); // Pull errorCode off of params\n\n  let errorCode = parsedSearch.errorCode;\n  delete parsedSearch.errorCode; // Get hash (#abc=example)\n\n  let parsedHash = {};\n\n  if (parts[1]) {\n    parsedHash = qs.parse(hash);\n  } // Merge search and hash\n\n\n  let params = { ...parsedSearch,\n    ...parsedHash\n  };\n  return {\n    errorCode,\n    params\n  };\n}\n\nfunction _warnIfAnonymous(id, url) {\n  if (id.startsWith('@anonymous/')) {\n    console.warn(\"You are not currently signed in to Expo on your development machine. As a result, the redirect URL for AuthSession will be \\\"\".concat(url, \"\\\". If you are using an OAuth provider that requires whitelisting redirect URLs, we recommend that you do not whitelist this URL -- instead, you should sign in to Expo to acquired a unique redirect URL. Additionally, if you do decide to publish this app using Expo, you will need to register an account to do it.\"));\n  }\n}\n\nexport default {\n  dismiss,\n  getRedirectUrl,\n  getStartUrl,\n  getDefaultReturnUrl,\n\n  get getRedirectUri() {\n    console.warn('Use AuthSession.getRedirectUrl rather than AuthSession.getRedirectUri (Url instead of Uri)');\n    return getRedirectUrl;\n  },\n\n  startAsync\n};","map":null,"metadata":{},"sourceType":"module"}