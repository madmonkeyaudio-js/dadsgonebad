{"ast":null,"code":"import Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport ExponentNotifications from './ExponentNotifications';\n\nlet _emitter;\n\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n  /* Don't mutate the original notification */\n\n\n  notification = { ...notification\n  };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {// It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  } // Delete any Android properties on iOS and merge the iOS properties on root notification object\n\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  } // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_'; // TODO: remove this before releasing\n// this will always be `true` for SDK 28+\n\nlet IS_USING_NEW_BINARY = typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id) {\n  try {\n    let channelString = await AsyncStorage.getItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n\n  return null;\n}\n\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function (callback) {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n} // This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\n\n\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id), JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(categoryId, actions) {\n    return ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: config => {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n\n  createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    } // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    } // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(notification) {\n    _validateNotification(notification);\n\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS !== 'android') {\n      return await ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n\n        return ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel);\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(notification, options = {}) {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now(); // Validate and process the notification data\n\n    _validateNotification(notification);\n\n    let nativeNotification = _processNotification(notification); // Validate `options.time`\n\n\n    if (options.time) {\n      let timeAsDateObj = null;\n\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      } // If we couldn't convert properly, throw an error\n\n\n      if (!timeAsDateObj) {\n        throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n      } // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n\n\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n      }\n\n      options = { ...options,\n        time: timeAsDateObj.getTime()\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n    } // Validate options.repeat\n\n\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n      }\n    }\n\n    if (Platform.OS !== 'android') {\n      if (options.repeat) {\n        console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options);\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel);\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId) {\n    if (!ExponentNotifications.dismissNotification) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n    }\n\n    return await ExponentNotifications.dismissNotification(notificationId);\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync() {\n    if (!ExponentNotifications.dismissAllNotifications) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n    }\n\n    return await ExponentNotifications.dismissAllNotifications();\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync() {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number) {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n    }\n\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n\n  async scheduleNotificationWithCalendarAsync(notification, options = {}) {\n    const areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n\n    if (!areOptionsValid) {\n      throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n    }\n\n    return ExponentNotifications.scheduleNotificationWithCalendar(notification, options);\n  },\n\n  async scheduleNotificationWithTimerAsync(notification, options) {\n    if (options.interval < 1) {\n      throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n    }\n\n    return ExponentNotifications.scheduleNotificationWithTimer(notification, options);\n  }\n\n};\n\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":null,"metadata":{},"sourceType":"module"}