{"ast":null,"code":"import Constants from 'expo-constants';\nimport qs from 'qs';\nimport Linking from './LinkingModule';\nconst manifest = Constants.manifest;\nconst USES_CUSTOM_SCHEME = Constants.appOwnership === 'standalone' && manifest.scheme;\nlet HOST_URI = manifest.hostUri;\n\nif (!HOST_URI && !USES_CUSTOM_SCHEME) {\n  // we're probably not using up-to-date xdl, so just fake it for now\n  // we have to remove the /--/ on the end since this will be inserted again later\n  HOST_URI = _removeScheme(Constants.linkingUri).replace(/\\/--($|\\/.*$)/, '');\n}\n\nconst IS_EXPO_HOSTED = HOST_URI && (/^(.*\\.)?(expo\\.io|exp\\.host|exp\\.direct|expo\\.test)(:.*)?(\\/.*)?$/.test(HOST_URI) || manifest.developer);\n\nfunction _removeScheme(url) {\n  return url.replace(/^[a-zA-Z0-9+.-]+:\\/\\//, '');\n}\n\nfunction _removePort(url) {\n  return url.replace(/(?=([a-zA-Z0-9+.-]+:\\/\\/)?[^/]):\\d+/, '');\n}\n\nfunction _removeLeadingSlash(url) {\n  return url.replace(/^\\//, '');\n}\n\nfunction _removeTrailingSlash(url) {\n  return url.replace(/\\/$/, '');\n}\n\nfunction _removeTrailingSlashAndQueryString(url) {\n  return url.replace(/\\/?\\?.*$/, '');\n}\n\nfunction makeUrl(path = '', queryParams = {}) {\n  let scheme = 'exp';\n\n  if (Constants.appOwnership === 'standalone') {\n    scheme = manifest.scheme || manifest.detach && manifest.detach.scheme;\n  }\n\n  if (!scheme) {\n    throw new Error('Cannot make a deep link into a standalone app with no custom scheme defined');\n  }\n\n  let hostUri = HOST_URI || '';\n\n  if (USES_CUSTOM_SCHEME && IS_EXPO_HOSTED) {\n    hostUri = '';\n  }\n\n  if (path) {\n    if (IS_EXPO_HOSTED && hostUri) {\n      path = \"/--/\".concat(_removeLeadingSlash(path));\n    }\n\n    if (!path.startsWith('/') && hostUri) {\n      path = \"/\".concat(path);\n    } else if (path.startsWith('/') && !hostUri) {\n      path = path.substr(1);\n    }\n  } else {\n    path = '';\n  } // merge user-provided query params with any that were already in the hostUri\n  // e.g. release-channel\n\n\n  let queryString = '';\n  let queryStringMatchResult = hostUri.match(/(.*)\\?(.+)/);\n\n  if (queryStringMatchResult) {\n    hostUri = queryStringMatchResult[1];\n    queryString = queryStringMatchResult[2];\n    let paramsFromHostUri = {};\n\n    try {\n      let parsedParams = qs.parse(queryString);\n\n      if (typeof parsedParams === 'object') {\n        paramsFromHostUri = parsedParams;\n      }\n    } catch (e) {}\n\n    queryParams = { ...queryParams,\n      ...paramsFromHostUri\n    };\n  }\n\n  queryString = qs.stringify(queryParams);\n\n  if (queryString) {\n    queryString = \"?\".concat(queryString);\n  }\n\n  hostUri = _removeTrailingSlash(hostUri);\n  return encodeURI(\"\".concat(scheme, \"://\").concat(hostUri).concat(path).concat(queryString));\n}\n\nfunction parse(url) {\n  if (!url) {\n    throw new Error('parse cannot be called with a null value');\n  } // iOS client sometimes strips out the port from the initial URL\n  // even when it's included in the hostUri.\n  // This function should be able to handle both cases, so we strip off the port\n  // both here and from the hostUri.\n\n\n  let decodedUrl = _removePort(decodeURI(url));\n\n  let path;\n  let queryParams = {};\n  let queryStringMatchResult = decodedUrl.match(/(.*)\\?(.+)/);\n\n  if (queryStringMatchResult) {\n    decodedUrl = queryStringMatchResult[1];\n    queryParams = qs.parse(queryStringMatchResult[2]);\n  } // strip off the hostUri from the host and path\n\n\n  let hostUri = HOST_URI || '';\n\n  let hostUriStripped = _removePort(_removeTrailingSlashAndQueryString(hostUri));\n\n  if (hostUriStripped && decodedUrl.indexOf(hostUriStripped) > -1) {\n    path = decodedUrl.substr(decodedUrl.indexOf(hostUriStripped) + hostUriStripped.length);\n  } else {\n    path = _removeScheme(decodedUrl);\n  }\n\n  path = _removeLeadingSlash(path);\n\n  if (IS_EXPO_HOSTED && !USES_CUSTOM_SCHEME && path.startsWith('--/')) {\n    path = path.substr(3);\n  } else if (path.indexOf('+') > -1) {\n    path = path.substr(path.indexOf('+') + 1);\n  }\n\n  return {\n    path,\n    queryParams\n  };\n}\n\nasync function parseInitialURLAsync() {\n  const initialUrl = await Linking.getInitialURL();\n\n  if (!initialUrl) {\n    return {\n      path: null,\n      queryParams: null\n    };\n  }\n\n  return parse(initialUrl);\n} // @ts-ignore fix this...\n\n\nlet newLinking = new Linking.constructor();\nnewLinking.makeUrl = makeUrl;\nnewLinking.parse = parse;\nnewLinking.parseInitialURLAsync = parseInitialURLAsync;\nexport default newLinking;","map":null,"metadata":{},"sourceType":"module"}